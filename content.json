[{"title":"JAVA8_2","date":"2020-05-19T11:57:50.000Z","path":"2020/05/19/JAVA8-2/","text":"JAVA8（2）函数式接口 &ensp; &ensp; &ensp; &ensp; 函数式接口就是只有一个抽象方法的的接口，可以使用@FunctionInterface修饰，它可以检查这个接口是否是函数式接口 函数式接口 参数类型 返回类型 用途 BiFuction&lt;T,U,R&gt; T,U R 对类型为T，U参数应用操作，返回R类型的的结果包含方法为R apply(T t,U u); UnaryOperator(Function子接口) T T 对类型为T的对象进行一元运算，并返回T类型的结果，包含方法T apply(T t) BinaryOperator（BiFuction子接口） T,T T 对类型为T,U的对象进行二元运算，并且返回T类型的结果，包含方法T apply(T t1,T t2) BiConsumer&lt;T,U&gt; T,U void 对类型为T，U参数应用操作包含方法为 void accpet（T他，U u） ToIntFunction ToLongFunction ToDoubleFunction T int Long double 分别计算 int、long 、 double值的函数 IntFunction LongFunction DoubleFunction int Long double R 参数分别为int、long、double类型的参数 新时间API 在java8之前我们处理时间Date、SimpleDateFormat、Calendar都存在线程不安全的问题，而且繁琐在java8中，他选择了一个优秀的时间类Joda-Time 计算事件运行的时间： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667/* Instant：时间戳 * Duration：持续时间，时间差 * LocalDate：只包含日期，比如：2019-02-02 * LocalTime：只包含时间，比如：23:12:10 * LocalDateTime：包含日期和时间，比如：2019-02-02 23:14:21 * Period：时间段 * ZoneOffset：时区偏移量，比如：+8:00 * ZonedDateTime：带时区的时间 * Clock：时钟，比如获取目前美国纽约的时间 *///旧时间long start =System.currentTimeMillis();//事件long end =System.currentTimeMillis();System.out.println(start-end);//java8中Instant start = Instant.now();//事件Instant end = Instant.now();Duration time = Duration.between(start, end);//毫秒long s=time.getSeconds();//秒long ms = time.toMillis();/*比较两个时间的间隔*///第一个时间Instant start = Instant.now();Instant end = Instant.now();Duration time = Duration.between(start, end);//第二个时间Instant start1 = Instant.now();Instant end1 = Instant.now();Duration time1 = Duration.between(start1, end1);//public boolean isNegative() 持续时间的总长度小于零，则为true，大于零false System.out.println(time.minus(time1).isNegative());//获取本地的时间和日期LocalDate dateNow = LocalDate.now();//根据年月日取日期：LocalDate dateStr = LocalDate.of(2019, 1, 1); // -&gt; 2019-01-01//根据字符串取：LocalDate endOfFeb = LocalDate.parse(\"2020-01-01\"); // 严格按照ISO8601 yyyy-MM-dd验证LocalTime timeNow = LocalTime.now();LocalTime time = LocalTime.of(22, 50, 56);//时间加算 HOURS可替换为年 月 周 日 时 分 秒 毫秒。。。 LocalTime.now().plus(1, ChronoUnit.HOURS);//等效于 plusHours(1)//时间格式化String data1 = dateNow.format(DateTimeFormatter.BASIC_ISO_DATE); // yyyMMddString data2 = dateNow.format(DateTimeFormatter.ISO_LOCAL_DATE); // yyyy-MM-ddString data3 = dateNow.format(DateTimeFormatter.ISO_LOCAL_TIME); // HH-mm-ss-msString data4 = dateNow.format(DateTimeFormatter.ofPattern(\"yyyy-MM-dd\")); // 指定格式（yyyy-MM-dd）String data5 = dateNow.format(DateTimeFormatter.ofPattern(\"今天是：YYYY年 MMMM dd日 E\", Locale.CHINESE)); // 今天是：yyyy年 MM月 dd日 星期//标准格式化DateTimeFormatter formatter = DateTimeFormatter.ofLocalizedDate(FormatStyle.FULL);String data6 = formatter.format(LocalDateTime.now());//查看当前的时区 Asia/ShanghaiZoneId defaultZone = ZoneId.systemDefault();//查看美国纽约当前的时间ZoneId usa = ZoneId.of(\"America/New_York\");LocalDateTime shanghai = LocalDateTime.now();LocalDateTime usaTime = LocalDateTime.now(usa);//带有时区的时间ZonedDateTime tiemZone = ZonedDateTime.now(defaultZone);System.out.println(tiemZone); //2020-01-01T11:03:05.926+08:00[Asia/Shanghai] 方法 说明 返回 date.isBefore（date1） 是否在之前 Boolean date.isAfter（date1） 是否在之后 Boolean date.until(today, ChronoUnit.DAYS) 计算时间差，单位可替换 时间差 转换中需要注意，java8之前Date是包含日期和时间的，而LocalDate只包含日期，LocalTime只包含时间，所以与Date在互转中，必定会丢失日期或者时间，或者会使用起始时间。如果转LocalDateTime ,详细的可以看这篇文档 https://iowiki.com/javatime/javatime_index.html 优秀的你今天别忘记分享奥！！！","tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"}]},{"title":"JAVA 8","date":"2020-05-08T15:37:37.000Z","path":"2020/05/08/JAVA-8/","text":"JAVA8(1)概述： &ensp; &ensp; &ensp; &ensp; 是什么让我选择了java8，是命运吗？是爱吗？🤮，好吧我自己也编不下去了，其实最先关注java8是因为Lambda和stream API，然后才了解到了他的一系列的数据结构和底层的优化，而且还是长期支持的版本,so你懂的！ 更快的速度： &ensp; &ensp; &ensp; &ensp; 效率和速度这是一个永远无法避免的问题，以前的底层结构z中方法区（堆中永久区的一部分，用于存放核心类库的信息，几乎不会被GC回收）总是被单独拎出来，因为一些厂商像sun公司的Hostpot他的JVM存在永久区而另外像IBM等一些公司已经移除了这一区域，在java8之后他统一取消了这一区域，出现Metaspace(元空间)，他和方法区的不同是他直接用的是物理内存发生内存溢出(out of memory error OOM)的异常发生的机率降低，同时永久区的改变使得JVM调优中的PremGenSize 、MaxPremGenSize 无效 ,取而代之的是MetaspaceSize和MaxMetaspaceSize； 数据结构的改变 &ensp; &ensp; &ensp; &ensp; 可能对于你来说这些不足以打动你但是，同时java8也对一些数据结构进行了改编，例如常用的HashMap,哈希算法因为碰撞会导致效率变低，在java8中他在原有的数组+链表的结构上引入了红黑树，这是一种自平衡的二叉查找树( symmetric binary B-trees )，除了添加都非常快。 &ensp; &ensp; &ensp; &ensp; Java7的ConcurrentHashMap中通过Segment引入了分段加锁机制用来解决并发中HashMap可能导致的死循环问题。而Java8又对ConcurrentHashMap进行了改动，除了引入红黑树外，还去除了Segment，那么在ava8是如何保证线程安全的呢？ &ensp; &ensp; &ensp; &ensp; 其实他内部采用了CAS( compare and swap )+ Synchronized ，锁的粒度： 原来是对需要进行数据操作的Segment加锁，现调整为对每个数组元素加锁（Node） &ensp; &ensp; &ensp; &ensp; CAS这是一种基于锁的操作，而且是乐观锁，在java中锁分为乐观锁和悲观锁。悲观锁是将资源锁住，等一个之前获得锁的线程释放锁之后，下一个线程才可以访问。而乐观锁采取了一种宽泛的态度，通过某种方式不加锁来处理资源，比如通过给记录加version来获取数据，性能较悲观锁有很大的提高。操作包含三个操作数 内存位置（V）、预期原值（A）和新值(B)。如果内存地址里面的值和A的值是一样的，那么就将内存里面的值更新成B。CAS是通过无限循环来获取数据的，若果在第一轮循环中，a线程获取地址里面的值被b线程修改了，那么a线程需要自旋，到下次循环才有可能机会执行 lambda表达式 &ensp; &ensp; &ensp; &ensp; 他是一个匿名的函数，可以理解为一段可以传递的代码（将代码像数据一样进行传递）。可以写出跟简洁、灵活的代码。作为一种更紧凑的代码风格，使java的语言表达能力得到了提升。 12345678List&lt;User&gt; list=Arrays.asList(new User(1L,\"zs\",\"male\"), new User(2L,\"ls\",\"male\"), new User(2L,\"ls\",\"female\") ); for (Object obj:list)&#123; System.out.println(obj.toString()); &#125; list.parallelStream().forEach(ls-&gt; System.out.println(ls)); stream API &ensp; &ensp; &ensp; &ensp; 上面同时展现了一个stream，什么是stream（流）?他其实是对于集合的计算，stream本身不会存储数据，改变源数据,他的操作是延迟的，也就是需要的时候才会执行。 &ensp; &ensp; &ensp; &ensp; 他其实是java7的Fork/Join，是一个并行执行任务框架 ，这一个框架会将任务拆分成若干小任务，然后连接结合，进行结果汇总。 ForkJoin采用了工作窃取（work-stealing）算法，若一个工作线程的任务队列为空没有任务执行时，便从其他工作线程中获取任务主动执行。为了实现工作窃取，在工作线程中维护了双端队列，窃取任务线程从队尾获取任务，被窃取任务线程从队头获取任务。这种机制充分利用线程进行并行计算，减少了线程竞争。但是当队列中只存在一个任务了时，两个线程去取反而会造成资源浪费。 常用的一些方法： 方法 说明 parallelStream() 并行流 stream() 串行流 中间操作 方法 说明 fileter (Predicate p) 过滤 distinct（） 通过流元素产生的hashcode和equals去除重复元素 limit（long maxSize） 截断，使其不超过最大值 skip（long n） 跳过元素 map（Function f） 接收一个函数作为参数，该函数会被应用到每个元素，并映射成新的元素 mapToDouble(ToDoubleFunction f) 接收一个函数作为参数，该函数会被应用到每个元素，并产生一个新的DoubleStream sort（） 按自然顺序排序（字典顺序） sorted（Comparator c） 按照比较器排序 终止操作 方法 说明 allMatch（Predicate p） 检查是否匹配所有元素 anyMatch（Predicate p） 检查是否至少匹配一个元素 noneMatch（Predicate p） 检查是否没有匹配的元素 findFirst（） 返回第一个元素 findAny（） 返回任意当前流中的元素 count（） 返回流中数据的元素个数 max（Comparator c） 返回流中最大的值 min（Comparator c） 返回流中最小的值 forEach（Consumer c） 内部迭代 reduce（T iden , BinaryOperator b） 可以将流中元素反复结合起来，得到一个值，返回T reduce（BianaryOperator b） 可以将流中元素反复结合起来，得到一个值。返回 collect(Collector c) 结果转换 Optional 类型 &ensp; &ensp; &ensp; &ensp; 这是一个允许结果为空值的对象，从而减少了空指针的发生，例如对数据进行过滤的时候常常没有满足条件的数据这个时候就可以使用Optional","tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"}]},{"title":"Hello World","date":"2020-04-28T01:28:25.769Z","path":"2020/04/28/HelloWord/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"},{"name":"tags","slug":"tags","permalink":"http://yoursite.com/tags/tags/"},{"name":"test","slug":"test","permalink":"http://yoursite.com/tags/test/"}]}]