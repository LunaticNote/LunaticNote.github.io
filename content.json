[{"title":"JAVA 8","date":"2020-05-08T15:37:37.000Z","path":"2020/05/08/JAVA-8/","text":"JAVA8(1)概述： ​ 是什么让我选择了java8，是命运吗？是爱吗？🤮，好吧我自己也编不下去了，其实最先关注java8是因为Lambda和stream API，然后才了解到了他的一系列的数据结构和底层的优化，而且还是长期支持的版本,so你懂的！ 更快的速度： ​ 效率和速度这是一个永远无法避免的问题，以前的底层结构z中方法区（堆中永久区的一部分，用于存放核心类库的信息，几乎不会被GC回收）总是被单独拎出来，因为一些厂商像sun公司的Hostpot他的JVM存在永久区而另外像IBM等一些公司已经移除了这一区域，在java8之后他统一取消了这一区域，出现了一Metaspace(元空间)，他和方法区的不同是他直接用的是物理内存发生内存溢出(out of memory error OOM)的异常发生的机率降低，同时永久区的改变使得JVM调优中的PremGenSize 、MaxPremGenSize 无效 ,取而代之的是MetaspaceSize和MaxMetaspaceSize； 数据结构的改变 ​ 可能对于你来说这些不足以打动你但是，同时java8也对一些数据结构进行了改编，嗯像HashMap,哈希算法因为碰撞会导致效率变低，在java8中他在原有的数组+链表的结构上引入了红黑树，这是一种自平衡的二叉查找树( symmetric binary B-trees )，除了添加都非常快。 ​ Java7的ConcurrentHashMap中通过Segment引入了分段加锁机制用来解决并发条件下HashMap可能导致的死循环问题。而Java8又对ConcurrentHashMap进行了改动，除了引入红黑树外，还去除了Segment，那么在ava8是如何保证线程安全的呢？ ​ 其实他内部采用了CAS( compare and swap )+ Synchronized ，锁的粒度： 原来是对需要进行数据操作的Segment加锁，现调整为对每个数组元素加锁（Node） ​ CAS这是一种基于锁的操作，而且是乐观锁，在java中锁分为乐观锁和悲观锁。悲观锁是将资源锁住，等一个之前获得锁的线程释放锁之后，下一个线程才可以访问。而乐观锁采取了一种宽泛的态度，通过某种方式不加锁来处理资源，比如通过给记录加version来获取数据，性能较悲观锁有很大的提高。操作包含三个操作数 内存位置（V）、预期原值（A）和新值(B)。如果内存地址里面的值和A的值是一样的，那么就将内存里面的值更新成B。CAS是通过无限循环来获取数据的，若果在第一轮循环中，a线程获取地址里面的值被b线程修改了，那么a线程需要自旋，到下次循环才有可能机会执行 lambda表达式 ​ 他是一个匿名的函数，可以理解为一段可以传递的代码（将代码像数据一样进行传递）。可以写出跟简洁、灵活的代码。作为一种更紧凑的代码风格，使java的语言表达能力得到了提升。 12345678List&lt;User&gt; list=Arrays.asList(new User(1L,\"zs\",\"male\"), new User(2L,\"ls\",\"male\"), new User(2L,\"ls\",\"female\") ); for (Object obj:list)&#123; System.out.println(obj.toString()); &#125; list.parallelStream().forEach(ls-&gt; System.out.println(ls)); stream API ​ 上面同时展现了一个stream，什么是stream（流）?他其实是对于集合的计算，stream本身不会存储数据，改变源数据,他的操作是延迟的，也就是需要的时候才会执行。 ​ 他其实是java7的Fork/Join，是一个并行执行任务框架 ，这一个框架会将任务拆分成若干小任务，然后连接结合，进行结果汇总。 ForkJoin采用了工作窃取（work-stealing）算法，若一个工作线程的任务队列为空没有任务执行时，便从其他工作线程中获取任务主动执行。为了实现工作窃取，在工作线程中维护了双端队列，窃取任务线程从队尾获取任务，被窃取任务线程从队头获取任务。这种机制充分利用线程进行并行计算，减少了线程竞争。但是当队列中只存在一个任务了时，两个线程去取反而会造成资源浪费。 常用的一些方法： 方法 说明 parallelStream() 并行流 stream() 串行流 中间操作 方法 说明 fileter (Predicate p) 过滤 distinct（） 通过流元素产生的hashcode和equals去除重复元素 limit（long maxSize） 截断，使其不超过最大值 skip（long n） 跳过元素 map（Function f） 接收一个函数作为参数，该函数会被应用到每个元素，并映射成新的元素 mapToDouble(ToDoubleFunction f) 接收一个函数作为参数，该函数会被应用到每个元素，并产生一个新的DoubleStream sort（） 按自然顺序排序（字典顺序） sorted（Comparator c） 按照比较器排序 终止操作 方法 说明 allMatch（Predicate p） 检查是否匹配所有元素 anyMatch（Predicate p） 检查是否至少匹配一个元素 noneMatch（Predicate p） 检查是否没有匹配的元素 findFirst（） 返回第一个元素 findAny（） 返回任意当前流中的元素 count（） 返回流中数据的元素个数 max（Comparator c） 返回流中最大的值 min（Comparator c） 返回流中最小的值 forEach（Consumer c） 内部迭代 reduce（T iden , BinaryOperator b） 可以将流中元素反复结合起来，得到一个值，返回T reduce（BianaryOperator b） 可以将流中元素反复结合起来，得到一个值。返回 collect(Collector c) 结果转换 Optional 类型 ​ 这是一个允许结果为空值的对象，从而减少了空指针的发生，例如对数据进行过滤的时候常常没有满足条件的数据这个时候就可以使用Optional","tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"}]},{"title":"Hello World","date":"2020-04-28T01:28:25.769Z","path":"2020/04/28/HelloWord/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"},{"name":"tags","slug":"tags","permalink":"http://yoursite.com/tags/tags/"},{"name":"test","slug":"test","permalink":"http://yoursite.com/tags/test/"}]}]